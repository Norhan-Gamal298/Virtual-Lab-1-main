# 4.Normalized Cut & Min Cut


##  Min Cut Segmentation

###  Concept

- Min Cut partitions the image graph into disjoint subsets by minimizing the total weight of the edges cut. However, it often produces unbalanced partitions (e.g., small isolated regions).

###  Equation

\[
\text{cut}(A, B) = \sum_{u \in A, v \in B} w(u, v)
\]

##### Where:

- ##### A, B: two partitions
- ##### w(U, V): weight (similarity) between nodes U and V

---

##  Normalized Cut (Ncut)

###  Concept

- Normalized Cut improves Min Cut by considering both dissimilarity across groups and similarity within groups, avoiding small isolated clusters.

###  Equation

\[
\text{Ncut}(A, B) = \frac{\text{cut}(A, B)}{\text{assoc}(A, V)} + \frac{\text{cut}(A, B)}{\text{assoc}(B, V)}
\]

##### Where:

\[
assoc(A, V)=\sum_{u \in A, t \in V} w(u, t)
\]

---

![alt](photows/NormalizCut&MinCut.jpg)

##  Python Code 

```python
% Read the image and convert to double precision
image = imread('sample.jpg');
image = im2double(image);

% Convert image to grayscale (optional)
gray = rgb2gray(image);

% Apply Sobel filter to detect edges (optional)
edges = imgradient(gray, 'sobel');

% Generate superpixels (approximately 400 segments)
numSegments = 400;
[L, N] = superpixels(image, numSegments);

% Build Region Adjacency Graph (RAG) based on mean colors
meanColors = zeros(N, 3);
for k = 1:N
    mask = (L == k);
    for c = 1:3
        channel = image(:,:,c);
        meanColors(k,c) = mean(channel(mask));
    end
end

% Create adjacency matrix for RAG using color similarity
weights = zeros(N);
for i = 1:N
    for j = i+1:N
        distColor = norm(meanColors(i,:) - meanColors(j,:));
        weights(i,j) = exp(-distColor * 10);
        weights(j,i) = weights(i,j);
    end
end

% Construct graph from adjacency matrix
G = graph(weights);

% Approximate Min Cut by clustering the graph into segments (thresholding)
% Here, as MATLAB does not have cut_threshold, use a simple clustering method
threshold = 0.5;
adjacencyThresholded = weights > threshold;
G_thresh = graph(adjacencyThresholded);
bins_min_cut = conncomp(G_thresh);

% Apply Normalized Cut approximation by spectral clustering
bins_norm_cut = clusterdata(weights, 'maxclust', 5);

% Map cluster labels back to superpixels for display
labels_min_cut = zeros(size(L));
labels_norm_cut = zeros(size(L));
for i = 1:N
    labels_min_cut(L == i) = bins_min_cut(i);
    labels_norm_cut(L == i) = bins_norm_cut(i);
end

% Display results
figure;
subplot(1,3,1)
imshow(image)
title('Original Image')
axis off

subplot(1,3,2)
imagesc(labels_min_cut)
title('Min Cut Segmentation (approx.)')
axis off
colormap('jet')

subplot(1,3,3)
imagesc(labels_norm_cut)
title('Normalized Cut Segmentation (approx.)')
axis off
colormap('jet')

```

## MATLAB Code 

```matlab
% Read image
image = imread('sample.jpg');

% Convert to RGB if image is grayscale
if size(image,3) == 1
    image_rgb = repmat(image, [1 1 3]);
else
    image_rgb = image;
end

% Convert to grayscale (optional)
gray = rgb2gray(image_rgb);

% Apply Sobel filter to detect edges (optional)
edges = edge(gray, 'sobel');

% Generate Superpixels using SLIC
numSuperpixels = 400;
compactness = 30;
[labels, numLabels] = superpixels(image_rgb, numSuperpixels, 'Compactness', compactness);

% Display boundaries of superpixels on original image (optional visualization)
BW = boundarymask(labels);
figure;
imshow(imoverlay(image_rgb, BW, 'cyan'));
title('Superpixel Boundaries');

% Calculate mean color for each superpixel region
meanColors = zeros(numLabels, 3);
for k = 1:numLabels
    mask = labels == k;
    for c = 1:3
        channel = image_rgb(:,:,c);
        meanColors(k,c) = mean(channel(mask));
    end
end

% Build Region Adjacency Graph (RAG) based on superpixel labels
% Create adjacency matrix where edge weight is color difference
adjMatrix = zeros(numLabels);

% Find adjacency between superpixels by checking neighboring pixels
[height, width, ~] = size(image_rgb);
idxOffsets = [0 1; 1 0; 1 1; 1 -1]; % 4-connected neighborhood + diagonals

for r = 1:height
    for c = 1:width
        currentLabel = labels(r,c);
        for i = 1:size(idxOffsets,1)
            nr = r + idxOffsets(i,1);
            nc = c + idxOffsets(i,2);
            if nr >= 1 && nr <= height && nc >= 1 && nc <= width
                neighborLabel = labels(nr, nc);
                if neighborLabel ~= currentLabel
                    % Calculate color distance as edge weight
                    colorDist = norm(meanColors(currentLabel,:) - meanColors(neighborLabel,:));
                    adjMatrix(currentLabel, neighborLabel) = colorDist;
                    adjMatrix(neighborLabel, currentLabel) = colorDist;
                end
            end
        end
    end
end

% Min Cut segmentation approximation: Threshold edges in RAG
thresh = 29; % Threshold similar to Python code
adjMatrixThresh = adjMatrix;
adjMatrixThresh(adjMatrix > thresh) = 0;

% Find connected components in thresholded graph for segmentation
G = graph(adjMatrixThresh);
bins = conncomp(G);

% Create segmented image using min cut labels
minCutLabels = zeros(size(labels));
for k = 1:numLabels
    minCutLabels(labels == k) = bins(k);
end

% Normalize minCutLabels to display as image
minCutDisplay = uint8(255 * mat2gray(minCutLabels));

% Normalized Cut segmentation - approximation (MATLAB does not have direct normalized cut function)
% You can use spectral clustering on adjacency matrix

% Compute normalized graph Laplacian
D = diag(sum(adjMatrix, 2));
L = D - adjMatrix;
D_sqrt_inv = diag(1 ./ sqrt(diag(D) + eps));
L_norm = D_sqrt_inv * L * D_sqrt_inv;

% Compute eigenvectors
[eigVecs, eigVals] = eig(L_norm);

% Use second smallest eigenvector (Fiedler vector) for bipartition
[~, idx] = sort(diag(eigVals));
fiedlerVector = eigVecs(:, idx(2));

% Threshold Fiedler vector at zero to split graph into two parts
normCutLabels = ones(size(labels));
normCutLabels(ismember(labels, find(fiedlerVector > 0))) = 2;

% Normalize for display
normCutDisplay = uint8(255 * mat2gray(normCutLabels));

% Display results
figure;

subplot(1,3,1)
imshow(image_rgb)
title('Original Image')

subplot(1,3,2)
imshow(label2rgb(minCutLabels))
title('Min Cut Segmentation')

subplot(1,3,3)
imshow(label2rgb(normCutLabels))
title('Normalized Cut Segmentation (Approx.)')

```

![alt](photows/NormalizedCut&MinCut.png)



